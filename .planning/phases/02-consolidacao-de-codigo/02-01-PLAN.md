---
phase: 02-consolidacao-de-codigo
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/core.sh
autonomous: true

must_haves:
  truths:
    - "core.sh contains all runtime utility functions with core_ prefix"
    - "Sourcing core.sh provides core_need_cmd, core_assert_file, core_spin, core_retry, core_run_or_die"
    - "Module guard prevents double-sourcing"
  artifacts:
    - path: "lib/core.sh"
      provides: "Unified core + runtime utilities with core_ prefix"
      contains: "core_need_cmd"
    - path: "lib/core.sh"
      provides: "Spin function for UI with core_ prefix"
      contains: "core_spin()"
  key_links:
    - from: "lib/core.sh"
      to: "DCX_GO"
      via: "_dc_find_binary for gum"
      pattern: "_dc_find_binary gum"
---

<objective>
Merge runtime.sh utility functions into core.sh with core_ prefix

Purpose: Eliminate module split between core.sh and runtime.sh - core.sh becomes the single entry point for all library functionality. All runtime functions are renamed with core_ prefix per CONTEXT.md decision.
Output: Updated lib/core.sh with all runtime utilities integrated using core_ function names
</objective>

<execution_context>
@/home/marlonsc/.claude/get-shit-done/workflows/execute-plan.md
@/home/marlonsc/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-consolidacao-de-codigo/02-CONTEXT.md
@lib/core.sh
@lib/runtime.sh
</context>

<tasks>

<task type="auto">
  <name>Task 1: Merge runtime.sh content into core.sh with core_ prefix</name>
  <files>lib/core.sh</files>
  <action>
Add all functions from runtime.sh into core.sh in a new section "RUNTIME UTILITIES" after the "MODULE SYSTEM" section. **CRITICAL: Rename ALL functions to use core_ prefix**.

1. Add section header:
```bash
#===============================================================================
# RUNTIME UTILITIES
#===============================================================================
```

2. Copy these functions from runtime.sh WITH core_ prefix (keep existing documentation, update function names):
   - need_cmd() → core_need_cmd()
   - need_cmds() → core_need_cmds()
   - assert_file() → core_assert_file()
   - assert_dir() → core_assert_dir()
   - assert_nonempty() → core_assert_nonempty()
   - assert_var() → core_assert_var()
   - spin() → core_spin()
   - retry() → core_retry()
   - timeout_cmd() → core_timeout_cmd()
   - run_silent() → core_run_silent()
   - run_or_die() → core_run_or_die()

3. Modify core_spin() to use _dc_find_binary for gum discovery (not raw command -v):
```bash
core_spin() {
    local title="$1"
    shift
    local gum_bin
    gum_bin=$(_dc_find_binary gum) || gum_bin=""
    if [[ -n "$gum_bin" && -t 0 && -t 1 ]]; then
        "$gum_bin" spin --title "$title" -- "$@"
    else
        echo "$title"
        "$@"
    fi
}
```

4. Update the module registration in _dc_register_builtin_modules():
   - Remove the "runtime" module registration line entirely
   - Update "config" to depend on "logging" instead of "runtime"
   - Update "parallel" to depend on "logging" instead of "runtime"

Do NOT delete runtime.sh yet - that happens in Plan 02.
  </action>
  <verify>
Run syntax check: `bash -n lib/core.sh`
Run: `bash -c 'source lib/core.sh && type core_need_cmd && type core_spin && type core_retry'`
Verify functions are defined with core_ prefix and callable.
  </verify>
  <done>
core.sh contains all runtime utility functions with core_ prefix.
`bash -n lib/core.sh` passes.
Sourcing core.sh makes core_need_cmd, core_spin, core_retry, and other utilities available.
  </done>
</task>

<task type="auto">
  <name>Task 2: Validate core.sh integration with core_ prefix</name>
  <files>lib/core.sh</files>
  <action>
Test the integrated core.sh works correctly with new core_ prefixed functions:

1. Verify basic functions work:
```bash
bash -c '
  source lib/core.sh
  # Test core_need_cmd
  core_need_cmd bash || exit 1
  ! core_need_cmd nonexistent_xyz 2>/dev/null || exit 2
  # Test core_assert_file
  core_assert_file lib/core.sh || exit 3
  ! core_assert_file /nonexistent 2>/dev/null || exit 4
  # Test core_assert_dir
  core_assert_dir lib || exit 5
  # Test core_assert_nonempty
  core_assert_nonempty "hello" "test" || exit 6
  ! core_assert_nonempty "" "test" 2>/dev/null || exit 7
  echo "All basic tests pass"
'
```

2. Verify core_spin with fallback (no gum):
```bash
bash -c '
  source lib/core.sh
  output=$(core_spin "Testing..." echo "hello")
  [[ "$output" == *"hello"* ]] || exit 1
  echo "core_spin fallback works"
'
```

3. Verify core_run_or_die works:
```bash
bash -c '
  source lib/core.sh
  core_run_or_die "Test should pass" true
  echo "core_run_or_die works"
'
```
  </action>
  <verify>
All validation commands exit 0.
No errors printed to stderr (except expected error messages from negative tests).
  </verify>
  <done>
core.sh runtime utilities work correctly in isolation with core_ prefix.
Basic function tests pass.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `bash -n lib/core.sh` - syntax valid
2. `bash -c 'source lib/core.sh && type core_need_cmd'` - function exists with core_ prefix
3. `bash -c 'source lib/core.sh && core_need_cmd bash'` - function works
4. `bash -c 'source lib/core.sh && type core_spin'` - core_spin exists
5. `bash -c 'source lib/core.sh && core_spin "Test" echo OK'` - core_spin works
</verification>

<success_criteria>
- lib/core.sh contains all functions from runtime.sh with core_ prefix
- Syntax check passes
- All runtime utilities are callable after sourcing core.sh (using core_* names)
- Module registry no longer references runtime module
- core_spin() uses _dc_find_binary for gum discovery
</success_criteria>

<output>
After completion, create `.planning/phases/02-consolidacao-de-codigo/02-01-SUMMARY.md`
</output>
